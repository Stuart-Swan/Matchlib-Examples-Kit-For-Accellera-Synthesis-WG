

See ../../doc/matchlib_memory_modeling_methodology.pdf

This example is very similar to example ../40_scratchpad however it uses
"ScratchpadClass", which is a scratchpad memory that is _not_ implemented
as a SystemC module with a separate process. Thus, Scratchpad class can
be directly synthesized within the calling HLS process.

This is a simple example and testcase for Scratchpad, which
is a banked memory without any arbitration or queuing of requests.
Because there is no arbitration or queueing of requests,
all addresses within a incoming requests presented to the Scratchpad memory must not have any conflicts
between the banks. It is the _users_ responsibility to insure that this is always true.
The crossbar model used within the ScratchpadClass memory will report in the pre-HLS
simulation if there are any conflicts in the bank requests.

Because there can never be any bank conflicts, 
there can never be any "backpressure" on incoming requests.
The memory is always able to accept new requests on each iteration, and it will return
read responses in order without any variation in delay.

Note that the low-order bits in the addresses within the request transaction are used
for the bank selection. In the Catapult HLS tool, this is similar to the INTERLEAVE directive,
which also builds a banked memory that is based on the low order bits.

See Scratchpad.h for more information on this class.

The example test shown within testbench.cpp and dut.h here is a simple use
of scratchpad to store coefficient weights during the design start up, and
then perform multiply accumulate (MAC) operations using input weight data
that is streamed into the DUT. The pre-HLS and post-HLS models perform 16
reads of the scratchpad memory and 16 multiply opertions on each clock cycle,
thus producing a new MAC sum result on each clock cycle. Importantly, the coefficient
starting addresses are fully randomized (but all coefficients for the MAC operation
are contiguous in memory). Scratchpad is able to handle these design requirements
and achieve a full MAC output on each clock cycle in both the pre-HLS and post-HLS
models.

Also see ../../doc/memory_logging_and_debug.pdf  for a detailed description
of the memory logs generated by this example.

Steps:

1. Build the SystemC simulation executable by typing:
   make build

2. Run the SC simulation by typing:
   ./sim_sc

3. View the waveforms generated from the SC simulation:
   make view_wave

4. Run Catapult HLS to generate Verilog RTL for DUT:
   catapult -f go_hls.tcl

5. Launch SCVerify / QuestaSim with generated RTL by typing in Catapult command line:
   dofile scverify.tcl

6. Run RTL Sim by typing in QuestaSim command line:
   run -all
   wave zoom full

7. View the RTL simulation waveforms and compare to SC waveforms before HLS synthesis

8. Delete all generated files
    make clean
